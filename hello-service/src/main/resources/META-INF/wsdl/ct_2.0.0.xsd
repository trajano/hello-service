<?xml version="1.0" encoding="UTF-8"?>
<xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema"
	targetNamespace="urn:trajano.net:ct:2.0" xmlns="urn:trajano.net:ct:2.0"
	elementFormDefault="qualified">

	<xs:annotation>
		<!-- Documentation elements should be no more than 80 characters and have 
			xml:space="preserve" to ensure proper formatting. -->
		<xs:documentation xml:space="preserve">Common types (ct) schema. These types are common types used by applications and
are not to be extended or restricted.  This schema will only contain types, 
and abstract containment elements.  There will be be no other elements defined here.

The purpose of this schema is to provide examples of the more advanced XML
schema elements.

File naming and version standards:
* Follow Java conventions for versioning.
* File name starts with the prescribed prefix followed by an underscore
  then the version in v.v.v format.  All three digits have to be put in
  even if only the first value is used in the namespace.

Naming standards:
* element names are lower case.  To conform to XHTML.
* attribute names are lower case.  To conform to XHTML.
* Types are title case and does not end with Type.  This prevents the word
  Type from appearing in the generated code.
* Acronyms are treated as individual words, e.g. FooUrl or UuidString
* Enumerated types with static values are suffixed with Enum (e.g.
  ErrorLevelEnum).  Having this separated allows the creation of new types
  in the generated code.
* Enumerated types with extension to support other values are not suffixed.
  This is because they are not generated as enumerations anymore.
* Identifiers are suffixed as ID
* Reference numbers such as account number is suffixed with NO (e.g.
  AccountNO)
* DateTime (aka as Timestamps) are suffixed by TS
* Ranges are named "startXXX" and "endXXX".  Do not use from/to, start/finish.
* Dates are suffixed by Date (not DT)
* Enumeration values are all capitals unless there is a business requirement.

Namespace naming standards:
* urn:trajano.net:[prescribed_prefix]:[version]
* a point version (e.g. 2.1) provides extensions to existing types
* there is no guarantee for backwards compatibility for non-point versions.
* namespace version only goes up to two components.  The third component of
  the version is used for documentation fixes that to not change any
  structure.
  
Coding standards:
* use the schema namespace "xs" and the target namespace have no namespace
  prefix. This will allow derivations to just copy and paste more easily.
* do not redefine XML schema basic types unless there is a change or business
  meaning added.  For example: do not redefine xs:date as Date, but xs:token as
  AccountNO is okay.
* use xml:space="preserve" to prevent reformatting issues.
* Documentation text should not exceed 80 characters per line.
		</xs:documentation>
	</xs:annotation>

	<xs:element name="properties">
		<xs:annotation>
			<xs:documentation xml:space="preserve">Container for property elements.  Ensures uniqueness on the name attribute.</xs:documentation>
		</xs:annotation>
		<xs:complexType>
			<xs:sequence>
				<xs:element name="property" type="Property" minOccurs="0"
					maxOccurs="unbounded"></xs:element>
			</xs:sequence>
		</xs:complexType>
		<xs:unique name="propertyName">
			<xs:selector xpath="*"></xs:selector>
			<xs:field xpath="@name"></xs:field>
		</xs:unique>
	</xs:element>


	<xs:complexType name="Property">
		<xs:annotation>
			<xs:documentation>This is a property. However, the
				value
				is made to be
				typed. This element should be referred by a containing element.
			</xs:documentation>
		</xs:annotation>
		<xs:choice>
			<xs:element name="value" type="xs:anySimpleType" />
			<xs:element name="text">
				<xs:simpleType>
					<xs:restriction base="xs:string">
						<xs:whiteSpace value="preserve"></xs:whiteSpace>
					</xs:restriction>
				</xs:simpleType>
			</xs:element>
			<xs:element name="uri" type="xs:anyURI"></xs:element>
			<xs:element name="date" type="xs:date"></xs:element>
			<xs:element name="language" type="xs:language"></xs:element>
			<xs:element name="uuid" type="Uuid"></xs:element>
			<xs:element name="amount" type="CurrencyAmount"></xs:element>
		</xs:choice>
		<xs:attribute name="name" type="xs:token"></xs:attribute>
	</xs:complexType>

	<xs:complexType name="ApplicationFault">
		<xs:annotation>
			<xs:documentation xml:space="preserve">Fault type for SOAP applications that provides application context. This is
what is normally thrown.

It should contain a map of stuff. The objective is
simplicity rather than best practice; which is to use a separate schema rather than name value
				pairs although
				there is no reason why we cannot have it.

An ApplicationFaultType also contains itself in order to do chained or
				for multiple validation messages.
			</xs:documentation>
		</xs:annotation>
		<xs:all>
			<xs:element name="stackTrace" maxOccurs="1" minOccurs="0">
				<xs:annotation>
					<xs:documentation>
						This contains the stack trace represented as a
						string. This is populated using
						Exception.printStackTrace(PrintStream). This
						value is optional
						because the stack trace is
						more for troubleshooting, but may
						contain
						information that the service provider may not
						want to show.
					</xs:documentation>
				</xs:annotation>
				<xs:simpleType>
					<xs:restriction base="xs:string">
						<xs:whiteSpace value="preserve"></xs:whiteSpace>
					</xs:restriction>
				</xs:simpleType>
			</xs:element>
			<xs:element ref="properties" maxOccurs="1" minOccurs="0">
				<xs:annotation>
					<xs:documentation xml:space="preserve"> Extra information that may be sent. This is built as a property list rather
than using an any type to ensure inter-operability between different XML
Schema binding stacks.
					</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="chainedFaults" minOccurs="0" maxOccurs="1">
				<xs:complexType>
					<xs:sequence>
						<xs:element name="fault" type="ApplicationFault"
							minOccurs="0" maxOccurs="unbounded"></xs:element>
					</xs:sequence>
				</xs:complexType>
			</xs:element>
		</xs:all>
		<xs:attribute name="errorCode" use="required">
			<xs:annotation>
				<xs:documentation>
					This is the error code that represents the
					message.
					This is meant to be used by clients for
					looking up
					localized
					versions of fault messages
					if any. This is made mandatory
					as this
					fault
					should provide proper application messages.
					</xs:documentation>
			</xs:annotation>
			<xs:simpleType>
				<xs:restriction base="xs:token">
					<xs:minLength value="1"></xs:minLength>
				</xs:restriction>
			</xs:simpleType>
		</xs:attribute>
		<xs:attribute name="message" use="required">
			<xs:annotation>
				<xs:documentation>
					This is a non-localized message representing the
					fault. It is meant for debugging problems and
					not meant to be seen
					by the client. This is
					mandatory.
					</xs:documentation>
			</xs:annotation>
			<xs:simpleType>
				<xs:restriction base="xs:string">
					<xs:minLength value="1"></xs:minLength>
				</xs:restriction>
			</xs:simpleType>
		</xs:attribute>
		<xs:attribute name="level" use="optional" type="ErrorLevel"
			default="ERROR">
			<xs:annotation>
				<xs:documentation xml:space="preserve">The error level.  Generally it would be ERROR for the most part as such it is
set as the default as such the use of this attribute is optional.  WARNING may
be used for validation warnings and INFO may just be information messages
thrown via a fault.

The purpose of this is to show something on the client end as to the severity
of the error as understood by the application and not necessarily an actual
representation of the severity of the error itself.

TBD: Should this be named as a fault or just a simple application message that
may get passed into an exception or just another data structure?</xs:documentation>
			</xs:annotation>
		</xs:attribute>
	</xs:complexType>

	<xs:simpleType name="ErrorLevelEnum">
		<xs:annotation>
			<xs:documentation xml:space="preserve">These are possible error level values.</xs:documentation>
		</xs:annotation>
		<xs:restriction base="xs:token">
			<xs:enumeration value="ERROR"></xs:enumeration>
			<xs:enumeration value="WARNING"></xs:enumeration>
			<xs:enumeration value="INFO"></xs:enumeration>
		</xs:restriction>
	</xs:simpleType>
	<xs:simpleType name="ErrorLevel">
		<xs:union memberTypes="xs:token ErrorLevelEnum"></xs:union>
	</xs:simpleType>

	<xs:simpleType name="Amount">
		<xs:restriction base="xs:decimal">
			<xs:fractionDigits value="2"></xs:fractionDigits>
		</xs:restriction>
	</xs:simpleType>

	<xs:complexType name="CurrencyAmount">
		<xs:simpleContent>
			<xs:extension base="Amount">
				<xs:attribute name="currency" use="optional"></xs:attribute>
			</xs:extension>
		</xs:simpleContent>
	</xs:complexType>

	<xs:simpleType name="Uuid">
		<xs:annotation>
			<xs:documentation xml:space="preserve">This is a Universally Unique ID number. This is generated by the UUID function
in Java.  This is the only type that violates the naming rule of ID being the
suffix because of aethetic reasons.</xs:documentation>
		</xs:annotation>
		<xs:restriction base="xs:token">
			<xs:pattern
				value="^[0-9a-f]{8}\-[0-9a-f]{4}\-[0-9a-f]{4}\-[0-9a-f]{4}\-[0-9a-f]{12}$">
			</xs:pattern>
			<xs:length value="36" />
		</xs:restriction>
	</xs:simpleType>
</xs:schema>