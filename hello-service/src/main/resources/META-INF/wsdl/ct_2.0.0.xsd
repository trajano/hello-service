<?xml version="1.0" encoding="UTF-8"?>
<xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema"
	targetNamespace="urn:trajano.net:ct:2.0" xmlns="urn:trajano.net:ct:2.0"
	elementFormDefault="qualified">

	<xs:annotation>
		<!-- Documentation elements should be no more than 80 characters and have 
			xml:space="preserve" to ensure proper formatting. -->
		<xs:documentation xml:space="preserve">Common types (ct) schema. These types are common types used by applications and
are not to be extended or restricted.  This schema will only contain types, 
and abstract containment elements.  There will be be no other elements defined here.

The purpose of this schema is to provide examples of the more advanced XML
schema elements.

File naming and version standards:
* Follow Java conventions for versioning.
* File name starts with the prescribed prefix followed by an underscore
  then the version in v.v.v format.  All three digits have to be put in
  even if only the first value is used in the namespace.

Naming standards:
* element names are lower case.  To conform to XHTML.
* attribute names are lower case.  To conform to XHTML.
* Types are title case and does not end with Type.  This prevents the word
  Type from appearing in the generated code.
* Acronyms are treated as individual words, e.g. FooUrl or UuidString
* Enumerated types with static values are suffixed with Enum (e.g.
  ErrorLevelEnum).  Having this separated allows the creation of new types
  in the generated code.
* Enumerated types with extension to support other values are not suffixed.
  This is because they are not generated as enumerations anymore.
* Identifiers are suffixed as ID
* Reference numbers such as account number is suffixed with NO (e.g.
  AccountNO)
* DateTime (aka as Timestamps) are suffixed by TS.  It was chosen over DT
  because some people use DT as a suffix for Date (which we are not doing) and
  TS is less ambiguous.
* Ranges are named "startXXX" and "endXXX".  Do not use from/to, start/finish.
* Dates are suffixed by Date (not DT).   It was chosen over DT
  because some people use DT as a suffix for DateTime (which we are not doing)
  and Date is less ambiguous.
* Times are suffixed by TM
* Enumeration values are in sentence case unless there is a business
  requirement.

Namespace naming standards:
* urn:trajano.net:[prescribed_prefix]:[version]
* a point version (e.g. 2.1) provides extensions to existing types
* there is no guarantee for backwards compatibility for non-point versions.
* namespace version only goes up to two components.  The third component of
  the version is used for documentation fixes that to not change any
  structure.
  
Coding standards:
* use the schema namespace "xs" and the target namespace have no namespace
  prefix. This will allow derivations to just copy and paste more easily.
* do not redefine XML schema basic types unless there is a change or business
  meaning added.  For example: do not redefine xs:date as Date, but xs:token as
  AccountNO is okay.
* use xml:space="preserve" to prevent reformatting issues.
* Documentation text should not exceed 80 characters per line.
* Use attributes for enumerations if possible.
* Use tokens for enumerations if possible.
* Use xml:lang to denote language specific values rather than creating a custom
  attribute.
* Do not create an ID type element to represent a unique instance.  Use xml:id.

When to use attributes vs. elements:
* Use elements for long running text (usually those of string or
  normalizedString types) 
* Do not use an attribute if there is grouping of two values (e.g.
  eventStartDate and eventEndDate) for an element.  In the previous example,
  there should be a new element for "event" which may contain the startDate and
  endDate attributes.
* Use elements if the type will be complex.
* Use attributes if the value is a simple type and does not repeat.
		</xs:documentation>
	</xs:annotation>
	<xs:import namespace="http://www.w3.org/XML/1998/namespace"
		schemaLocation="http://www.w3.org/2001/xml.xsd">
		<xs:annotation>
			<xs:documentation>Provides xml:lang.</xs:documentation>
		</xs:annotation>
	</xs:import>

	<xs:element name="properties">
		<xs:annotation>
			<xs:documentation xml:space="preserve">Container for property elements.  Ensures uniqueness on the name attribute.</xs:documentation>
		</xs:annotation>
		<xs:complexType>
			<xs:sequence>
				<xs:element name="property" type="Property" minOccurs="0"
					maxOccurs="unbounded"></xs:element>
			</xs:sequence>
		</xs:complexType>
		<xs:unique name="propertyName">
			<xs:selector xpath="*"></xs:selector>
			<xs:field xpath="@name"></xs:field>
		</xs:unique>
	</xs:element>

	<xs:complexType name="Property">
		<xs:annotation>
			<xs:documentation xml:space="preserve">This is a property. However, the value is made to be
typed. This element should be referred by a containing element.
			</xs:documentation>
		</xs:annotation>
		<xs:choice>
			<xs:element name="value" type="xs:anySimpleType" />
			<xs:element name="text">
				<xs:simpleType>
					<xs:restriction base="xs:string">
						<xs:whiteSpace value="preserve"></xs:whiteSpace>
					</xs:restriction>
				</xs:simpleType>
			</xs:element>
			<xs:element name="uri" type="xs:anyURI"></xs:element>
			<xs:element name="date" type="xs:date"></xs:element>
			<xs:element name="language" type="xs:language"></xs:element>
			<xs:element name="uuid" type="Uuid"></xs:element>
			<xs:element name="version" type="Version"></xs:element>
			<xs:element name="amount" type="CurrencyAmount"></xs:element>
		</xs:choice>
		<xs:attribute name="name" type="xs:token"></xs:attribute>
	</xs:complexType>

	<xs:complexType name="ApplicationFault">
		<xs:annotation>
			<xs:documentation xml:space="preserve">Fault type for SOAP applications that provides application context. This is
what is normally thrown.

The sequence model was used rather than all in order to support group
references.

It should contain a map of stuff. The objective is
simplicity rather than best practice; which is to use a separate schema rather than name value
				pairs although
				there is no reason why we cannot have it.

An ApplicationFaultType also contains itself in order to do chained or
				for multiple validation messages.
			</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:group ref="MessageGroup"></xs:group>
			<xs:element name="stackTrace" maxOccurs="1" minOccurs="0">
				<xs:annotation>
					<xs:documentation>
						This contains the stack trace represented as a
						string. This is populated using
						Exception.printStackTrace(PrintStream). This
						value is optional
						because the stack trace is
						more for troubleshooting, but may
						contain
						information that the service provider may not
						want to show.
					</xs:documentation>
				</xs:annotation>
				<xs:simpleType>
					<xs:restriction base="xs:string">
						<xs:whiteSpace value="preserve"></xs:whiteSpace>
					</xs:restriction>
				</xs:simpleType>
			</xs:element>
			<xs:element ref="properties" maxOccurs="1" minOccurs="0">
				<xs:annotation>
					<xs:documentation xml:space="preserve"> Extra information that may be sent. This is built as a property list rather
than using an any type to ensure inter-operability between different XML
Schema binding stacks.
					</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="chainedFaults" minOccurs="0" maxOccurs="1">
				<xs:complexType>
					<xs:sequence>
						<xs:element name="fault" type="ApplicationFault"
							minOccurs="0" maxOccurs="unbounded"></xs:element>
					</xs:sequence>
				</xs:complexType>
			</xs:element>
			<xs:group ref="DescriptionGroup"></xs:group>
		</xs:sequence>
		<xs:attribute name="errorCode" use="required">
			<xs:annotation>
				<xs:documentation xml:space="preserve">
This is the error code that represents the message. This is meant to be used by
clients for looking up localized versions of fault messages if any. This is
made mandatory to ensure there is a proper error value even if it is just a
code.</xs:documentation>
			</xs:annotation>
			<xs:simpleType>
				<xs:restriction base="xs:token">
					<xs:minLength value="1"></xs:minLength>
				</xs:restriction>
			</xs:simpleType>
		</xs:attribute>
		<xs:attribute name="level" use="optional" type="ErrorLevel"
			default="ERROR">
			<xs:annotation>
				<xs:documentation xml:space="preserve">The error level.  Generally it would be ERROR for the most part as such it is
set as the default as such the use of this attribute is optional.  WARNING may
be used for validation warnings and INFO may just be information messages
thrown via a fault.

The purpose of this is to show something on the client end as to the severity
of the error as understood by the application and not necessarily an actual
representation of the severity of the error itself.

TBD: Should this be named as a fault or just a simple application message that
may get passed into an exception or just another data structure?</xs:documentation>
			</xs:annotation>
		</xs:attribute>
	</xs:complexType>

	<xs:simpleType name="ErrorLevelEnum">
		<xs:annotation>
			<xs:documentation xml:space="preserve">These are possible error level values.</xs:documentation>
		</xs:annotation>
		<xs:restriction base="xs:token">
			<xs:enumeration value="ERROR"></xs:enumeration>
			<xs:enumeration value="WARNING"></xs:enumeration>
			<xs:enumeration value="INFO"></xs:enumeration>
		</xs:restriction>
	</xs:simpleType>
	<xs:simpleType name="ErrorLevel">
		<xs:union memberTypes="xs:token ErrorLevelEnum"></xs:union>
	</xs:simpleType>

	<xs:simpleType name="Amount">
		<xs:restriction base="xs:decimal">
			<xs:fractionDigits value="2"></xs:fractionDigits>
		</xs:restriction>
	</xs:simpleType>

	<xs:complexType name="CurrencyAmount">
		<xs:simpleContent>
			<xs:extension base="Amount">
				<xs:attribute name="currency" use="optional"></xs:attribute>
			</xs:extension>
		</xs:simpleContent>
	</xs:complexType>

	<xs:simpleType name="Uuid">
		<xs:annotation>
			<xs:documentation xml:space="preserve">This is a Universally Unique ID number. This is generated by the UUID function
in Java.  This is the only type that violates the naming rule of ID being the
suffix because of aethetic reasons.</xs:documentation>
		</xs:annotation>
		<xs:restriction base="xs:token">
			<xs:pattern
				value="^[0-9a-f]{8}\-[0-9a-f]{4}\-[0-9a-f]{4}\-[0-9a-f]{4}\-[0-9a-f]{12}$">
			</xs:pattern>
			<xs:length value="36" />
		</xs:restriction>
	</xs:simpleType>

	<xs:simpleType name="Version">
		<xs:annotation>
			<xs:documentation xml:space="preserve">This represents a version.  It only uses numbers seperated by periods as that
makes it easier to do sorting opererations.</xs:documentation>
		</xs:annotation>
		<xs:restriction base="xs:token">
			<xs:pattern value="^(\d+\.)+\d+$">
			</xs:pattern>
		</xs:restriction>
	</xs:simpleType>

	<xs:simpleType name="IpAddress">
		<xs:restriction base="xs:token">
			<xs:pattern
				value="((1?[0-9]?[0-9]|2[0-4][0-9]|25[0-5]).){3}(1?[0-9]?[0-9]|2[0-4][0-9]|25[0-5])">
				<xs:annotation>
					<xs:documentation
						source="http://mailman.ic.ac.uk/pipermail/xml-dev/1999-December/018018.html"></xs:documentation>
				</xs:annotation>
			</xs:pattern>
		</xs:restriction>
	</xs:simpleType>
	
	<xs:complexType name="LocalizedString">
		<xs:simpleContent>
			<xs:extension base="xs:string">
				<xs:attribute ref="xml:lang" use="required">
					<xs:annotation>
						<xs:documentation xml:space="preserve">This attribute is required even if the value is "".</xs:documentation>
					</xs:annotation>
				</xs:attribute>
			</xs:extension>
		</xs:simpleContent>
	</xs:complexType>

	<xs:group name="DescriptionGroup">
		<xs:annotation>
			<xs:documentation xml:space="preserve">This provides a simple text describing an object or multiple text that provide
different language versions of a description.</xs:documentation>
		</xs:annotation>
		<xs:choice>
			<xs:element name="description" minOccurs="0" type="xs:string"></xs:element>
			<xs:element name="localizedDescription" minOccurs="0"
				type="LocalizedString" maxOccurs="unbounded"></xs:element>
		</xs:choice>
	</xs:group>

	<xs:group name="MessageGroup">
		<xs:annotation>
			<xs:documentation xml:space="preserve">This provides a simple text describing an object or multiple text that provide
different language versions of a message.  Unlike descriptions, messages must
have some text.</xs:documentation>
		</xs:annotation>
		<xs:choice>
			<xs:element name="message" minOccurs="0">
				<xs:simpleType>
					<xs:restriction base="xs:string">
						<xs:minLength value="1"></xs:minLength>
					</xs:restriction>
				</xs:simpleType>
			</xs:element>
			<xs:element name="localizedMessage" minOccurs="0"
				maxOccurs="unbounded">
				<xs:complexType>
					<xs:simpleContent>
						<xs:restriction base="LocalizedString">
							<xs:minLength value="1"></xs:minLength>
							<xs:attribute ref="xml:lang" use="required"></xs:attribute>
						</xs:restriction>
					</xs:simpleContent>
				</xs:complexType>

			</xs:element>
		</xs:choice>
	</xs:group>

	<xs:attributeGroup name="DateRangeGroup">
		<xs:attribute name="startDate" type="xs:date" use="optional"></xs:attribute>
		<xs:attribute name="endDate" type="xs:date" use="optional"></xs:attribute>
	</xs:attributeGroup>
	<xs:attributeGroup name="DateTimeRangeGroup">
		<xs:attribute name="startTS" type="xs:dateTime" use="optional"></xs:attribute>
		<xs:attribute name="endTS" type="xs:dateTime" use="optional"></xs:attribute>
	</xs:attributeGroup>
</xs:schema>
