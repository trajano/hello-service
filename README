Web Service Reference Implementation
====================================

This is a reference implementation of a web service that has the following
requirements:

* Contract First WSDL development [done]
* Performance Logging [done]
* Database connectivity (with JPA)
* Asynchronous web service (if possible)
* Simple web client
* Simple command line client
* ant build script

It has the following technical objectives:
* Leverage standards as much as possible.
* Work with Eclipse JST
* Work with Maven
* Work with Spring, but keep Spring involvement minimal if a standard
  option is available

Notes on approach:
* CXF usage was removed (though it is a better stack than the standard) as
  a standard approach was available.
* .classpath and other files are part of version control as there is no
  good way of working with JST and Maven at the moment.

When you checkout the project from GIT before using, run mvn package.

Maven integration still sucks for Eclipse when doing anything that deals with
facets such as dynamic web projects.  However, it is still better than
maintaining extra code (i.e. Ant build files).

For real-life, I would recommend Maven to bootstrap the project, then
use Ant to do the builds, because there are more people who know Ant than
Maven (caters to the lower denominator).  I would still try to use the Maven
source structures if possible, at least on Eclipse it works.




This example project utilizes a contract first development approach.  It also
uses EJBs as the web service implementation for the end points rather than
Web Applications.  The hypothesis is that you can keep the WSDLs with the EJB
module.  Although you can do the same thing in a Web Application, the web
application can do more than just web service itself.  So we have it broken
up this way so only one set of business logic is provided and it will be 
separated from any web related stuff.

As a bonus you get a Stateless Session Bean interface for free.

This example project lumps all levels (service implementation, service
interface, integration test) in one project.  This is not recommended for
real-life.  I would break things up in the following way:

* Web Service container project.  This will contain all the web services for 
the enterprise (?).  There should be no CXF or other WS runtimes here.
We should be using whatever JAX-WS runtime is provided.  Bootstrap
configuration should be in java:comp/env

Although JAX-WS allows for you to specify a wsdlLocation in the @WebService
annotation it seems to only work in WEB-INF/wsdl and the standards do not
explicitly state that this can be inside an included JAR's META-INF/wsdl
folder.  This means the approach will require the maven-dependency-plugin
to extract the files and put it in the folder.

Ideally the grouping should be one per enterprise group.

* Service Implementation project.  This will contain only the implementation
of a service class.  Ideally one WSDL implementation per Service
Implementation project.  It uses wsimport to generate the interface code
from a request to a deployed web service container project.

The WSDL should be stored in META-INF/wsdl so we can extract the data using
the maven-dependency-plugin.

* Service Implementation Integration Test.  This is a support project for
those than need to test integration for a deployed project.

* Web Service EAR.  This will contain multiple web service container projects.
Ideally the versioning should be based on a release schedule be it by year
or half year (like Ubuntu) or monthly (if you do things that quickly).

There is no such thing as a client project.  Unlike Stateless Session Beans,
WSDL already provides the information to build the client and the interface
for any language that supports it.  Therefore, don't add any more work for
yourself.
